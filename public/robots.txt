# Backend Architecture Guide - In-Depth Explanation

## ğŸ“ Folder Structure

```
backend/
â”œâ”€â”€ server.js                    # Main entry point
â”œâ”€â”€ config/
â”‚   â””â”€â”€ db.js                    # Database configuration
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ playerController.js      # Player HTTP request handlers
â”‚   â”œâ”€â”€ roomController.js        # Room HTTP request handlers
â”‚   â””â”€â”€ historyController.js     # History HTTP request handlers
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ playerService.js         # Player business logic
â”‚   â”œâ”€â”€ roomService.js           # Room business logic
â”‚   â””â”€â”€ gameService.js           # Core game mechanics
â”œâ”€â”€ sockets/
â”‚   â””â”€â”€ gameSocketHandler.js     # WebSocket event handlers
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ playerRoutes.js          # Player API routes
â”‚   â”œâ”€â”€ roomRoutes.js            # Room API routes
â”‚   â””â”€â”€ historyRoutes.js         # History API routes
â””â”€â”€ model/
    â””â”€â”€ Flip7/
        â”œâ”€â”€ Player.js            # Player schema
        â”œâ”€â”€ GameRoom.js          # Game room schema
        â””â”€â”€ GameHistory.js       # Game history schema
```

---

## ğŸ—ï¸ Architecture Layers Explained

### 1. **server.js - Application Entry Point**

**Purpose**: Bootstrap the entire application

**Responsibilities**:
- Initialize Express app
- Create HTTP server for both REST API and WebSocket
- Connect to MongoDB database
- Configure CORS for cross-origin requests
- Set up middleware (body parser)
- Mount routes (tell Express which URLs map to which route files)
- Initialize socket.io handlers
- Start the server listening on a port

**Why separate from other files?**
- Keeps initialization logic centralized
- Easy to test and maintain
- Clear separation of concerns

**Key Concept**: 
```javascript
const io = socketIO(server, {...})
```
This attaches Socket.IO to the HTTP server, enabling both REST endpoints (GET, POST) and WebSocket connections to share the same port.

---

### 2. **Controllers Layer**

**Purpose**: Handle HTTP request/response cycle

**Analogy**: Think of controllers as restaurant waiters. They:
- Take orders (receive HTTP requests)
- Validate the order (check req.body, req.params)
- Pass order to kitchen (call service layer)
- Serve the food (send response back to client)

**What Controllers DO**:
- âœ… Extract data from `req.body`, `req.params`, `req.query`
- âœ… Validate input (is username present? is it too long?)
- âœ… Call appropriate service methods
- âœ… Format responses with proper HTTP status codes
- âœ… Handle errors and send error responses
- âœ… Keep code thin - just coordination logic

**What Controllers DON'T DO**:
- âŒ Don't contain business logic (calculations, game rules)
- âŒ Don't directly interact with database (that's service layer)
- âŒ Don't manipulate data structures extensively

**Example Flow**:
```
Client Request â†’ Controller validates â†’ Service processes â†’ Controller formats response â†’ Client
```

**Why separate?**
- Single Responsibility: One file handles one resource type
- Testability: Easy to mock and test
- Reusability: Services can be called from multiple controllers

---

### 3. **Services Layer**

**Purpose**: Contains all business logic and data manipulation

**Analogy**: Think of services as the restaurant kitchen. They:
- Know the recipes (business logic)
- Cook the food (process data)
- Store ingredients (interact with database)
- Can be called by multiple waiters (reused across controllers and sockets)

**What Services DO**:
- âœ… Implement game rules and mechanics
- âœ… Perform database operations (create, read, update, delete)
- âœ… Handle complex calculations
- âœ… Contain reusable functions
- âœ… Return data (not HTTP responses)
- âœ… Throw errors for controllers to catch

**What Services DON'T DO**:
- âŒ Don't access `req` or `res` objects (those are HTTP-specific)
- âŒ Don't send HTTP responses
- âŒ Don't handle socket emissions directly

**Example: playerService.js**
```javascript
async createPlayer(username) {
  const playerId = this.generatePlayerId();
  const player = new Player({ playerId, username });
  await player.save();
  return player; // Return data, not HTTP response
}
```

**Why separate?**
- **Reusability**: Same service can be used by controllers AND socket handlers
- **Testability**: Pure functions without HTTP concerns
- **Maintainability**: Business logic in one place
- **Flexibility**: Easy to add new features

---

### 4. **Socket Handlers**

**Purpose**: Manage real-time WebSocket connections

**Why Separate from Controllers?**

Controllers and Socket Handlers serve different communication protocols:

| Controllers (HTTP) | Socket Handlers (WebSocket) |
|-------------------|----------------------------|
| Request/Response model | Bidirectional communication |
| One request = one response | Continuous connection |
| Stateless | Stateful (connection persists) |
| REST endpoints | Event-based |

**What Socket Handlers DO**:
- âœ… Listen to socket events (`flipCard`, `joinRoom`, etc.)
- âœ… Validate socket data
- âœ… Call service layer for business logic
- âœ… Emit responses to specific clients or rooms
- âœ… Manage socket rooms (grouping connections)
- âœ… Handle disconnections and reconnections

**Example Flow**:
```
Client emits 'flipCard' â†’ Socket handler receives â†’ 
Calls gameService.processCard() â†’ Emits 'cardFlipped' to all players
```

**Key Socket.IO Concepts**:

```javascript
// Join a room (group sockets together)
socket.join(roomId);

// Emit to everyone in a room
io.to(roomId).emit('cardFlipped', data);

// Emit only to sender
socket.emit('error', { message: 'Not your turn' });

// Listen to events
socket.on('flipCard', async (data) => { ... });
```

**Why this pattern?**
- **Real-time Updates**: All players see card flips instantly
- **Room Isolation**: Game events only go to players in that game
- **Efficiency**: No polling, server pushes updates

---

### 5. **Routes Layer**

**Purpose**: Define API endpoint mapping

**Analogy**: Routes are like a restaurant menu. They tell you:
- What dishes are available (endpoints)
- How to order them (HTTP methods: GET, POST, etc.)

**What Routes DO**:
- âœ… Define URL patterns (`/api/players/:playerId`)
- âœ… Map URLs to controller methods
- âœ… Apply middleware (authentication, validation)
- âœ… Group related endpoints

**Example**:
```javascript
// routes/playerRoutes.js
router.post("/register", playerController.registerPlayer);
// Maps POST /api/players/register â†’ playerController.registerPlayer()

router.get("/:playerId", playerController.getPlayer);
// Maps GET /api/players/P12345 â†’ playerController.getPlayer()
```

**Why separate?**
- **Organization**: All player endpoints in one file
- **Maintainability**: Easy to see all available endpoints
- **Middleware**: Easy to add authentication or logging to specific routes

---

## ğŸ”„ Request Flow Examples

### HTTP REST Request Flow

```
1. Client: POST /api/players/register
   â†“
2. server.js: Express receives request
   â†“
3. routes/playerRoutes.js: Matches "/register" endpoint
   â†“
4. controllers/playerController.js: registerPlayer method
   - Validates username
   - Extracts data from req.body
   â†“
5. services/playerService.js: createPlayer method
   - Generates playerId
   - Creates Player model
   - Saves to database
   - Returns player object
   â†“
6. Controller: Formats response
   - res.status(201).json({ success: true, player })
   â†“
7. Client: Receives JSON response
```

### WebSocket Event Flow

```
1. Client: socket.emit('flipCard', { roomId, playerId })
   â†“
2. server.js: Socket.IO receives event
   â†“
3. sockets/gameSocketHandler.js: 'flipCard' listener
   - Validates it's player's turn
   - Checks if player is frozen
   â†“
4. services/gameService.js: processCard method
   - Applies game rules
   - Updates player state
   - Returns shouldEndTurn flag
   â†“
5. Socket Handler: Saves room to database
   - Emits 'cardFlipped' to all players in room
   - If shouldEndTurn, calls handleEndTurn
   â†“
6. All Clients in Room: Receive 'cardFlipped' event
   - Update UI with new card
   - Show messages
```

---

## ğŸ¯ Key Architectural Benefits

### 1. **Separation of Concerns**
Each layer has one clear responsibility:
- **Controllers**: HTTP handling
- **Services**: Business logic
- **Sockets**: Real-time communication
- **Routes**: Endpoint mapping
- **Models**: Data structure

### 2. **Reusability**
Services can be called from:
- HTTP controllers
- Socket handlers
- Other services
- Background jobs (future feature)

Example:
```javascript
// Called from controller (HTTP)
const player = await playerService.createPlayer(username);

// Called from socket handler (WebSocket)
const player = await playerService.createPlayer(username);

// Same function, different contexts!
```

### 3. **Testability**
Each layer can be tested independently:
```javascript
// Test service without HTTP
const player = await playerService.createPlayer("TestUser");
expect(player.username).toBe("TestUser");

// Test controller with mocked service
const mockService = { createPlayer: jest.fn() };
```

### 4. **Maintainability**
- Bug in game logic? Check `gameService.js`
- API endpoint issue? Check `routes/` and `controllers/`
- Socket connection problem? Check `sockets/gameSocketHandler.js`

### 5. **Scalability**
Easy to add new features:
```javascript
// Add new endpoint
router.post("/leaderboard", playerController.getLeaderboard);

// Add new service method
async getLeaderboard() { ... }

// Add new socket event
socket.on('sendMessage', async (data) => { ... });
```

---

## ğŸ”§ How Services and Controllers Communicate

### Pattern: Controller â†’ Service â†’ Controller

```javascript
// 1. Controller receives HTTP request
async registerPlayer(req, res) {
  const { username } = req.body;
  
  // 2. Controller validates input (HTTP-specific)
  if (!username) {
    return res.status(400).json({ error: "Username required" });
  }
  
  // 3. Controller calls service (business logic)
  const player = await playerService.createPlayer(username);
  
  // 4. Controller formats HTTP response
  res.status(201).json({ success: true, player });
}
```

### Pattern: Socket â†’ Service â†’ Socket

```javascript
// 1. Socket handler receives event
socket.on('flipCard', async ({ roomId, playerId }) => {
  
  // 2. Socket validates (socket-specific checks)
  if (playerIndex !== room.currentTurn) {
    return socket.emit('error', { message: 'Not your turn' });
  }
  
  // 3. Socket calls service (same as controller would!)
  const { shouldEndTurn, message } = gameService.processCard(...);
  
  // 4. Socket emits to clients
  io.to(roomId).emit('cardFlipped', { room, message });
});
```

**Key Insight**: Both use the same services! This is the power of separation.

---

## ğŸ“Š Data Flow Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚ (React/Vue/Mobile App)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€ HTTP Requests â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                          â”‚
       â””â”€â”€â”€ WebSocket Events â”€â”€â”€â”€â”€â”¤
                                  â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   server.js     â”‚
                         â”‚  (Entry Point)  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                           â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   Routes       â”‚         â”‚    Sockets     â”‚
            â”‚  (URL Mapping) â”‚         â”‚  (Event Mgmt)  â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                           â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
            â”‚  Controllers   â”‚                 â”‚
            â”‚ (HTTP Handler) â”‚                 â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
                    â”‚                           â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   Services     â”‚
                        â”‚ (Business Logic)â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚    Models      â”‚
                        â”‚   (Database)   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ Quick Reference

### When to use each layer:

**Use Controllers when:**
- Handling HTTP requests
- Validating user input
- Formatting API responses
- Setting HTTP status codes

**Use Services when:**
- Implementing game rules
- Performing calculations
- Interacting with database
- Logic needed by multiple parts of app

**Use Socket Handlers when:**
- Managing real-time connections
- Handling game events
- Broadcasting to multiple clients
- Managing socket rooms

**Use Routes when:**
- Defining new API endpoints
- Organizing related endpoints
- Adding middleware to specific routes

---

## âœ… Best Practices Applied

1. **Don't Repeat Yourself (DRY)**: Services prevent code duplication
2. **Single Responsibility**: Each file has one clear job
3. **Dependency Injection**: Services don't know about HTTP or sockets
4. **Error Handling**: Errors bubble up from services to handlers
5. **Async/Await**: Clean asynchronous code throughout
6. **Naming Conventions**: Clear, descriptive names for functions and files

This architecture makes your backend professional, scalable, and maintainable! ğŸ‰